cc是基于项目文件夹的工具，它在生成claude.md时会参考整个codebase代码库，这也就意味着如果你启动cc的这个目录空间里有不同项目，它就会全部参考，也就会让出现上下文混乱和逻辑冲突的概率大大增加。

简易之就是你在做一个新需求时，他既会参考你空间里的A项目，也会参考B项目，这就很容易出错，所以强烈建议每个完整项目都有自己的单独文件夹，然后在终端里进入到这些嵌套的具体项目文件里去启动cc，然后参考的codebase就只是这个项目文件里的了。

# 模式选择
在cc中有3种模式，通过shift+tab可以切换，分别是普通模式、plan模式、自动接受代码编辑模式。
- 普通模式：进入主界面就是普通模式
- plan模式：这个模式只会去讨论沟通，不会执行写代码，在项目前期需要规划功能的时候可以用到这个模式，它会自动给到计划方案，然后会和你确认是否执行
- 自动接受编辑模式:这个模式就是根据和AI讨论的方案，它会自动进行任务执行比如写代码；

建议一开始用普通或plan模式，plan模式最佳，可以使劲和cc讨论你的需求，让他不断调方案，给文档建议，都确定好了后退出plan模式，切换到普通或自动接受模式进行相关执行。

# 思考模式
在claude code中可以通过think提示词来激活思考模式，有几个层级：
“think” < “think hard” < “think harder” < “ultrathink”，思考程度依次增强；

原理是通过调节“思考预算”（即模型在内部推理阶段可用的资源／token数）让模型在遇到复杂任务时“多花点时间思考”再出结果，，效果会更好，当然费用也会更多；

注意这个扩展思考模式不是切换模型，只是让同一个模型在内部保留更多推理步骤或token数来思考更久。

比如：*think harder 分析这段代码的作用*

# Claude.md创建
进入项目了解选择完模式后，在开始沟通具体需求前还有个环节可以操作，那就是claude.md；

这是一个特殊文件，类似官方提供的你和cc之间的备忘录，Claude 在开始对话时会自动将其内容拉入上下文，所以它既可以记录一些你个人的习惯如特殊偏好、常用命令、代码风格等，也可以针对项目记录一些具体项目要求，如项目背景、注意事项、测试说明等，总之一切你想要claude知悉的事项都可以写进入；

Claude. md分为用户级和项目级，用户级的意思是不关联项目，只要是在你这个用户名登陆下任何项目都会遵守这个claude.md 文档规则；而项目级则只对该项目生效，切换项目后就不会再遵守。

通过2种方式可以生成Claude.md：
1. 直接运行/init命令：会自动参考你的项目空间codebase生成文档；
2. 通过输入# 后面可直接添加memory的实际内容，然后让你选择是添加到用户级还是项目级，这个memory也就是claude的内容。

通过运行/memory 可以查看claude.md里的记录内容，项目级和用户级都可查看。

# 工作流管理
把上面前期环节都走完后，就可以来到真正的需求沟通和执行环节了。
这个环节我觉得最核心的就是一句话：文档，文档，还是文档；只要把需求细节都讲清楚，让他照着文档做，选个好模型，做出来的产品与预期不会偏离太多；具体工作流用的比较多的是spec。

_**spec工作流：**_
spec即规范规格，用规格文档来驱动AI开发，可以理解为这个规格是AI要遵守的唯一契约，必须按照spec文档做事执行；spec具体分4部分：

1. **写需求文档**：这个文档无关技术，主要是关于项目的描述，功能需求，目标人群等，把这些大的需求相关信息告诉AI，让AI生成一个规范文档，这是一个将模糊想法转化为结构化需求的过程。
2. **写技术文档**：然后把上面刚生成的规范文档以及你的一些技术偏好，项目相关约束如框架、语言，测试计划等发给AI，让他生成一个完整的技术文档。
3. **写TODO文档**：把上面的两个2文档再发给ai，让他参考这2个文档把你的功能需求按确认后的技术偏好拆分成一个个具体的、可执行的子任务，每个任务都可以独立实现和测试。
4. **实现Implementation**：让他先把上面的3个文档汇总成一个大的spec.md发给你确认，如果觉得有问题就修改，确认无误后发给ai，让他进行代码编写开干。
  
相比claude.md来说，spec文档会更侧重于具体功能的详细实现计划，claude.md会相对更大一点，当然对于简单小需求，只写一个即可；

这个spec工作流解决的最大问题就是上下文问题，现在模型上下文都很有限，如果上下文用满后再开一个窗口不能把这些上下文内容100%记录，就会造成上下文丢失，开发效果会大大折扣，而文档记录正好解决了这一问题，可以让AI能看到完整的上下文背景信息。

我个人工作流习惯是：
1. 先自己写个大致文档需求
2. 然后发给ai和他基于这个文档讨论沟通，让他给我建议；
3. 然后让他把讨论过程中我确认的信息再完整复述给我，我来确认，确保双方理解无误；
4. 确认无误后让他更新到我之前的文档中，这些文档会包含上面提到的spec完整环节比如技术文档、任务拆分等，生成最终文档；
5. 将最终文档发给他，让他开始执行，你最后测试需求效果；

# 工具实战指南
> **Plugin 系统**让它从工具变成平台，**Subagent** 让它更智能地理解和执行任务，**MCP 增强**让它能连接更广阔的工具生态。

## 场景1: 微服务拆分决策(高风险架构决策)
背景: 单体应用用户量暴涨,考虑拆微服务,但怕拆坏了。

第1步: 深度思考(sequential-thinking MCP)  
"分析我们这个单体应用,是否适合拆微服务? 考虑:团队规模(15人)、技术栈(Spring Boot単体)、QPS(5000)、业务复杂度、运维能力、迁移成本"  
-> 返回: 完整推理链, 3个方案对比 (不拆/部分拆/全拆)  
  
第2步: 查技术方案(context7 MCP)  
"查Spring Cloud Alibaba的服务拆分最佳实践和Seata分布式事务方案"  
-> 返回: 官方文档相关章节, 4种事务方案对比  
  
第3步: 记录决策(memory MCP)  
"记住:我们的微服务拆分原则: 1、按业务域拆,不按技术层拆 2、优先拆读多写少的服务..."  
  
第4步: 制定执行计划(SubAgent: backend-architect)  
"基于上述决策,制定详细的微服务拆分计划: 1、识别服务边界 2、设计迁移方案(分阶段,可回滚)..."  
-> 返回: 6步完整迁移计划

## 场景2: 生产事故快速响应(争分夺秒)
说:"线上支付服务挂了,订单超时率80%"  
  
自动触发Skill: incident-response  
  
阶段1: 并行排查(3个SubAgent同时工作)  
- devops-troubleshooter → 扫描日志,发现大量数据库慢查询  
- performance-engineer → CPU/内存正常,但数据库连接池打满  
- database-optimizer → 发现某个SQL从0.1s变成5s  
  
阶段2: 根因定位(sequential-thinking MCP)  
"基于上述数据,分析根因: - SQL为何突然变慢? - 为何今天才出问题?..."  
-> 返回: 根因:订单表数据量突破1000万,某个未加索引的查询开始全表扫描  
  
阶段3: 生成止损方案(Skill内部逻辑)  
-> 返回: 3个方案对比 (快速/中期/根治)  
  
阶段4: 执行(一键复制命令)  
-> 输出可执行命令 (kubectl scale..., ALTER TABLE...)  
  
最后: 记录到memory (memory MCP)  
"记住:订单表到1000万行会有性能问题,需提前分库分表"

## 场景3: 接手遗留项目(快速上手)
背景: 接手一个2年没人维护的老项目,代码无文档。

第1步: 项目全貌扫描(SubAgent: Explore)  
"探索这个项目: 1、识别技术栈和依赖 2、找到核心模块和入口..."  
-> 返回(10分钟): 项目架构图, 核心模块清单, 风险清单  
  
第2步: 关键逻辑理解(并行调用3个SubAgent)  
- backend-architect → "分析用户登录流程的实现"  
- database-optimizer → "分析数据库表设计和关系"  
- security-auditor → "扫描常见安全漏洞"  
-> 返回: 登录流程时序图, ER图, 7个安全风险点  
  
第3步: 技术债评估(Skill: tech-debt-manager)  
-> 自动扫描代码,输出: 高优先级技术债(5个), 建议优先偿还的3个  
  
第4步: 依赖升级计划(Skill: dependency-upgrade-check)  
-> 检测到: 3个依赖有已知CVE漏洞, 生成分阶段升级计划  
  
第5步: 知识沉淀(memory MCP)  
"把这个项目的关键信息记住: - 核心模块和职责 - 数据库表和字段含义..."

## 场景4: 新功能完整开发流程(端到端)
Phase 1: 需求分析(sequential-thinking MCP)  
"分析积分系统需求: - 核心功能:赚积分、花积分... - 风险:超发、作弊、性能"  
-> 返回: 功能拆解, 技术方案选型(Redis+MySQL双写)  
  
Phase 2: 查技术方案(context7 MCP)  
"查Redis分布式锁的最佳实践和积分系统的反作弊方案"  
-> 返回: Redisson分布式锁示例, 防御手段  
  
Phase 3: 数据库设计(SubAgent: database-optimizer)  
"设计积分系统的数据库表结构..."  
-> 返回: 完整DDL, 索引设计  
  
Phase 4: 开发(写代码)  
正常开发过程
  
Phase 5: Code Review(Skill: smart-code-review)  
-> 自动触发: 检查并发安全, SQL性能, 异常处理...  
  
Phase 6: 提交前检查(斜杠命令: /commit)  
-> 自动执行: 运行单测, 检查代码规范, 生成commit message...  
  
Phase 7: 记录(memory MCP)  
"记住积分系统的实现: - 用Redis计数器+MySQL持久化..."

## 场景5: 技术栈升级(高风险迁移)
背景: Vue 2升级到Vue 3,涉及200+组件。

第1步: 影响面评估(SubAgent: frontend-developer)  
"分析这个Vue 2项目升级到Vue 3的影响: - 哪些API发生了breaking change..."  
-> 返回: 需要改动的文件清单(185个), 不兼容的库(3个), 估算工作量:15人天  
  
第2步: 查迁移指南(context7 MCP)  
"查Vue 3官方迁移指南和常见坑"  
-> 返回: 官方migration guide, 社区常见问题合集  
  
第3步: 制定迁移计划(sequential-thinking MCP)  
"制定分阶段、可回滚的Vue 3迁移计划..."  
-> 返回: 5个阶段的迁移计划, 每阶段的回滚方案  
  
第4步: 自动化迁移(Skill: migration-script)  
-> 用ast-grep批量替换: this.$xxx → composition API...  
  
第5步: 逐批验证(Skill: migration-validator)  
-> 每迁移一批: 运行单测, 运行E2E测试, 检查bundle size...  
  
第6步: 记录(memory MCP)  
"记住Vue 2→3迁移的坑: - Element UI要换成Element Plus..."

# 综合实战
基于你团队最烦的事,写一个Skill或斜杠命令(代码提交流程、PR创建流程、新人环境配置等)。

#### 验收标准(做到这5点算成功)
1、 说"查React 19最新文档",能调用context7返回结果
2、 说"分析该不该用微服务",能用sequential-thinking深度推理
3、 说"记住我们用PostgreSQL",下次相关问题能自动调用memory
4、 说"准备提交代码",能自动触发pre-commit-check (Skill)
5、 输入/release,能执行完整发布流程 (Slash Command) ）（用上面自己定义的slash command实现）
做到这5点,你的Claude就从 聊天助手 升级成 智能工作流系统 了。

# 最佳实践

1、不要贪多,先用3件套起步
- MCP: 必装memory + context7 + sequential-thinking
- Skills: 先写3个(代码检查、文档同步、依赖评估)
- SubAgents: 遇到复杂问题再调度,不用提前学
- 其他的,等这3个用顺了再说。

2、设计自己团队的工作流剧本

把团队最烦的3件事自动化:
	1、 代码提交流程(自动检查+commit)
	2、 生产事故响应(并行排查+生成方案)
	3、 新人入职流程(自动化环境+知识导入)

这3个做好,投入产出比最高。

3、让知识沉淀,而不只是用一次
- 用memory MCP记录:
	- 团队踩过的坑
	- 重要的架构决策
	- 经常用的配置和规范
- 好的工具链会自己长知识。